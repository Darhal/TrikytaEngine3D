#pragma once

#include <Core/Misc/Defines/Common.hpp>
#include <Core/Misc/Defines/Debug.hpp>
#include <sstream>
#include <vector>
#include <string>

TRE_NS_START

template<typename T, typename Alloc_t = MultiPoolAlloc>
class BinaryTree
{
public:
	struct BinaryTreeLeaf {
	public:
		template<typename... Args>
		BinaryTreeLeaf(BinaryTreeLeaf* r, BinaryTreeLeaf* l, Args&&... args) : right(r), left(l), element(std::forward<Args>(args)...)
		{}

		BinaryTreeLeaf* GetRight() { return right; }
		BinaryTreeLeaf* GetLeft() { return left; }
		T& GetElement() { return element; }

		void SetRight(BinaryTreeLeaf* r) { right = r; }
		void SetLeft(BinaryTreeLeaf* l) { left = l; }

		template<typename... Args>
		T& EmplaceRight(Args&&... args){
			right = m_Allocator.Allocate<BTLeaf>();
			new (right) BTLeaf(NULL, NULL, std::forward<Args>(args)...);
			return *right;
		}

		template<typename... Args>
		T& EmplaceLeft(Args&&... args){
			left = m_Allocator.Allocate<BTLeaf>();
			new (left) BTLeaf(NULL, NULL, std::forward<Args>(args)...);
			return *left;
		}

	public:
		T element;
		BinaryTreeLeaf* right;
		BinaryTreeLeaf* left;

		friend class BinaryTree<T, Alloc_t>;
	};

	typedef BinaryTreeLeaf BTLeaf;
	typedef BinaryTreeLeaf BTNode;
	typedef BinaryTreeLeaf Node;
public:
	FORCEINLINE BinaryTree();

	template<typename... Args>
	FORCEINLINE BinaryTree(Args&&... args);

	virtual ~BinaryTree();

	FORCEINLINE BTLeaf* GetRoot() const;
	FORCEINLINE BTLeaf* GetRight(BTLeaf* cur = NULL) const;
	FORCEINLINE BTLeaf* GetLeft(BTLeaf* cur = NULL) const;

	template<typename... Args>
	FORCEINLINE BTLeaf* InsertRight(BTLeaf* cur, Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* InsertLeft(BTLeaf* cur, Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* SetRoot(Args&&... args);

	template<typename... Args>
	FORCEINLINE BTLeaf* InsertTopRight(Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* InsertTopLeft(Args&&... args);

	FORCEINLINE void RemoveRight(BTLeaf* cur);
	FORCEINLINE void RemoveLeft(BTLeaf* cur);
	FORCEINLINE void RemoveNode(BTLeaf* cur);

	FORCEINLINE BTLeaf* RightRotate(BTLeaf* parent, BTLeaf* cur);
	FORCEINLINE BTLeaf* LeftRotate(BTLeaf* parent, BTLeaf* cur);

	FORCEINLINE usize MaxDepth(BTLeaf* cur = NULL) const;
	FORCEINLINE usize Height(BTLeaf* cur) const;

	FORCEINLINE usize Count(BTLeaf* cur);

	FORCEINLINE void Clear();

	FORCEINLINE bool IsEmpty() const;

	FORCEINLINE void Print(BTLeaf* node = NULL);
	FORCEINLINE void PrintBT(const String& prefix, const BTLeaf* node, bool isLeft);

	// Dumps a representation of the tree to cout
	void Dump() const;
protected:
	FORCEINLINE void DestroyTree(BTLeaf* cur);
	FORCEINLINE usize MaxDepthHelper(BTLeaf* cur) const;

	static const usize NODE_CHUNKS = 3;

	BTLeaf* m_Root;
	Alloc_t m_Allocator;

	struct cell_display {
		std::string   valstr;
		bool     present;
		cell_display() : present(false) {}
		cell_display(std::string valstr) : valstr(valstr), present(true) {}
	};

	using display_rows = std::vector< std::vector< cell_display > >;

	// The text tree generation code below is all iterative, to avoid stack faults.

	// get_row_display builds a vector of vectors of cell_display structs
	// each vector of cell_display structs represents one row, starting at the root
	display_rows get_row_display() const;

	// row_formatter takes the vector of rows of cell_display structs 
	// generated by get_row_display and formats it into a test representation
	// as a vector of strings
	std::vector<std::string> row_formatter(const display_rows& rows_disp) const;

	// Trims an equal number of space characters from
	// the beginning of each string in the vector.
	// At least one string in the vector will end up beginning
	// with no space characters.
	static void trim_rows_left(std::vector<std::string>& rows);
};

#include "BinaryTree.inl"

TRE_NS_END