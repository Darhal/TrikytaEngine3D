#pragma once

#include <Core/Misc/Defines/Common.hpp>
#include <Core/Misc/Defines/Debug.hpp>
#include <iostream>
#include <sstream>
#include <vector>
#include <string>
#include <utility>

TRE_NS_START

template<typename T, typename Alloc_t = MultiPoolAlloc>
class BinaryTree
{
public:
	class Iterator;

	struct BinaryTreeLeaf 
	{
	public:
		template<typename... Args>
		BinaryTreeLeaf(BinaryTreeLeaf* r, BinaryTreeLeaf* l, Args&&... args) : element(std::forward<Args>(args)...), right(r), left(l)
		{}

		BinaryTreeLeaf* GetRight() { return right; }
		BinaryTreeLeaf* GetLeft() { return left; }
		T& GetElement() { return element; }

		void SetRight(BinaryTreeLeaf* r) { right = r; }
		void SetLeft(BinaryTreeLeaf* l) { left = l; }

		template<typename... Args>
		T& EmplaceRight(Args&&... args){
			right = m_Allocator.template Allocate<BTLeaf>();
			new (right) BTLeaf(NULL, NULL, std::forward<Args>(args)...);
			return *right;
		}

		template<typename... Args>
		T& EmplaceLeft(Args&&... args){
			left = m_Allocator.template Allocate<BTLeaf>();
			new (left) BTLeaf(NULL, NULL, std::forward<Args>(args)...);
			return *left;
		}

	public:
		T element;
		BinaryTreeLeaf* right;
		BinaryTreeLeaf* left;

		friend class BinaryTree<T, Alloc_t>;
	};

	typedef BinaryTreeLeaf BTLeaf;
	typedef BinaryTreeLeaf BTNode;
	typedef BinaryTreeLeaf Node;

public:
	FORCEINLINE BinaryTree();

	template<typename... Args>
	FORCEINLINE BinaryTree(Args&&... args);

	virtual ~BinaryTree();

	FORCEINLINE BTLeaf* GetRoot() const;
	FORCEINLINE BTLeaf* GetRight(BTLeaf* cur = NULL) const;
	FORCEINLINE BTLeaf* GetLeft(BTLeaf* cur = NULL) const;

	template<typename... Args>
	FORCEINLINE BTLeaf* InsertRight(BTLeaf* cur, Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* InsertLeft(BTLeaf* cur, Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* SetRoot(Args&&... args);

	template<typename... Args>
	FORCEINLINE BTLeaf* InsertTopRight(Args&&... args);
	template<typename... Args>
	FORCEINLINE BTLeaf* InsertTopLeft(Args&&... args);

	FORCEINLINE void RemoveRight(BTLeaf* cur);
	FORCEINLINE void RemoveLeft(BTLeaf* cur);
	FORCEINLINE void RemoveNode(BTLeaf* cur);

	FORCEINLINE BTLeaf* RightRotate(BTLeaf* parent, BTLeaf* cur);
	FORCEINLINE BTLeaf* LeftRotate(BTLeaf* parent, BTLeaf* cur);

	FORCEINLINE usize MaxDepth(BTLeaf* cur = NULL) const;
	FORCEINLINE usize Height(BTLeaf* cur) const;

	FORCEINLINE usize Count(BTLeaf* cur);

	FORCEINLINE void Clear();

	FORCEINLINE bool IsEmpty() const;

	FORCEINLINE Iterator begin() noexcept;

	FORCEINLINE Iterator end() noexcept;

	FORCEINLINE const Iterator begin() const noexcept;

	FORCEINLINE const Iterator end() const noexcept;

	FORCEINLINE void Print(BTLeaf* node = NULL);
	FORCEINLINE void PrintBT(const String& prefix, const BTLeaf* node, bool isLeft);

	// Dumps a representation of the tree to cout
	// void Dump() const;

protected:
	FORCEINLINE void DestroyTree(BTLeaf* cur);
	FORCEINLINE usize MaxDepthHelper(BTLeaf* cur) const;

	static const usize NODE_CHUNKS = 3;

	BTLeaf* m_Root;
	Alloc_t m_Allocator;

	/*struct cell_display {
		std::string   valstr;
		bool     present;
		cell_display() : present(false) {}
		cell_display(std::string valstr) : valstr(valstr), present(true) {}
	};

	using display_rows = std::vector< std::vector< cell_display > >;

	// The text tree generation code below is all iterative, to avoid stack faults.

	// get_row_display builds a vector of vectors of cell_display structs
	// each vector of cell_display structs represents one row, starting at the root
	display_rows get_row_display() const;

	// row_formatter takes the vector of rows of cell_display structs 
	// generated by get_row_display and formats it into a test representation
	// as a vector of strings
	std::vector<std::string> row_formatter(const display_rows& rows_disp) const;

	// Trims an equal number of space characters from
	// the beginning of each string in the vector.
	// At least one string in the vector will end up beginning
	// with no space characters.
	static void trim_rows_left(std::vector<std::string>& rows);*/

public:

	class Iterator
	{
	public:
		Iterator(BinaryTree<T, Alloc_t>* instance) : m_TreeInstance(instance), m_Node(instance->m_Root)
		{};

		Iterator(BinaryTree<T, Alloc_t>* instance, Node* node) : m_TreeInstance(instance), m_Node(node)
		{};

		bool operator!=(const Iterator& iterator) { return m_Node != iterator.m_Node; }

		Node& operator*() const { return *m_Node; }

		Iterator& operator=(const Iterator& other)
		{
			this->m_Node = other.m_Node;
			this->m_TreeInstance = other.m_TreeInstance;
			return *this;
		}

		Iterator& operator++()
		{
			Node* parent = NULL;

			if (this->m_Node == NULL) {
				return *this; // end iterator does not increment
			}

			parent = this->m_Node->parent;

			// reaches root -> next is end()
			if (parent == NULL) {
				this->m_Node = NULL;
				return *this;
			}

			// left child -> go to right child
			if ((this->m_Node == parent->left) && parent->right != NULL) {
				this->m_Node = parent->right;
			}else {
				this->m_Node = this->m_Node->parent;
				return *this;
			}

			while (true) {
				if (this->m_Node->left != NULL) {
					this->m_Node = this->m_Node->left; // has left child node
				}else if (this->m_Node->right != NULL) {
					this->m_Node = this->m_Node->right; // only right child node
				}else {
					return *this; // has no children -> stop here
				}
			}
		}

		Iterator operator++(int)
		{
			Iterator iterator = *this;
			++(*this);
			return iterator;
		}

		Iterator& operator--()
		{
			// TODO: operator -- have to be implemented
			return *this;
		}

		Iterator operator--(int)
		{
			Iterator iterator = *this;
			--*this;
			return iterator;
		}

	private:
		Node* m_Node;
		BinaryTree<T, Alloc_t>* m_TreeInstance;
	};
};

#include "BinaryTree.inl"

TRE_NS_END